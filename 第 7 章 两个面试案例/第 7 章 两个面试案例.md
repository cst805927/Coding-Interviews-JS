# 第 7 章 两个面试案例

## 案例一：面试题 67 ：把字符串转换成整数

写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。

------

- 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。

- 当我们寻找到的第一个非空字符为正或者负号时，

  则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；

  - 假如第一个非空字符是数字，

    则直接将其与之后连续的数字字符组合起来，形成整数。

- 该字符串除了有效的整数部分之后

  也可能会存在多余的字符，

  这些字符可以被忽略，

  它们对于函数不应该造成影响。

- 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。


- 在任何情况下，若函数不能进行有效的转换时，请返回 0。


- 说明：

  - 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。

```
/**
 * @param {string} str
 * @return {number}
 */
const Status = {kValid : 0, kInvalid : 1}
let g_nStatus = Status.kValid
const INT_MAX = Math.pow(2, 31) - 1
const INT_MIN = -1 *Math.pow(2, 31)
var strToInt = function(str) {
    str = str.trim()
    g_nStatus = Status.kInvalid
    let num = 0
    let index = 0
    if (str.length) {
        let minus = false
        if (str[index] === '+') index++
        else if (str[index] === '-') {
            index++
            minus = true
        }
        if (index !== str.length)
            num = StrToIntCore(str, minus, index)
    }
    return num
};
function StrToIntCore(digit, minus, index) {
    let num = 0
    while (index !== digit.length) {
        if (digit[index] >= '0' && digit[index] <= '9') {
            let flag = minus ? -1 : 1
            num = num * 10 + flag * (digit[index] - 0)
            if ((!minus && num > INT_MAX) || num < INT_MIN) {
                num = minus ? INT_MIN: INT_MAX
                break
            }
            index++
        } else break
    }
    if (index === digit.length)
        g_nStatus = Status.kValid
    return num
}
```

### 测试用例

- 功能测试
  - 输入的字符串表示正数、负数、0
- 边界值测试
  - 最大的正整数
  - 最小的负整数
- 特殊输入测试
  - 输入的字符串为 空串
  - 输入的字符串中有非数字字符等

## 案例二 ：面试题 68 ：树中两个节点的最低公共祖先

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

------

- 二叉搜索树是排序过的

  位于左子树的节点都比父节点小

  位于右子树的节点都比父节点大

- 我们只需要从树的根节点开始和两个输入的节点进行比较

- 如果当前节点的值比两个节点的值都大

  那么最低的共同父节点一定在当前节点的左子树中

  - 于是下一步遍历当前节点的左子节点

- 如果当前节点的值比两个节点的值都小

  那么最低的共同父节点一定在当前节点的右子树中

  - 于是下一步遍历当前节点的右子节点

- 这样，从树中从上到下找到的

  第一个在两个输入节点的值之间的节点

  就是最低的公共祖先

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    if (p === q) return p
    let pNode = root
    const bigger = Math.max(p.val, q.val)
    const smaller = Math.min(p.val, q.val)
    while (pNode) {
        if (pNode.val <= bigger && pNode.val >= smaller) return pNode
        else if (pNode.val > bigger)
            pNode = pNode.left
        else if (pNode.val < smaller)
            pNode = pNode.right 
    }
    return pNode
};

```

### 