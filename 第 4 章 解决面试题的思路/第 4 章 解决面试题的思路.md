# 第 4 章 解决面试题的思路

## 4.2 画图让抽象问题形象化

- 二叉树、二维数组、链表
- 面试题 27 ：“ 二叉树的镜像 ”
- 面试题 29 ：“顺时针打印矩阵”
- 面试题 35 ：“复杂链表的复制”

### 面试题 27 ：二叉树的镜像

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

------

- 前序遍历每个节点

  - 如果遍历的节点有子节点

    就交换它的两个子节点

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var mirrorTree = function(root) {
    if (!root) return null
    if (!root.left && !root.right) return root
    MirrorRecursively(root)
    function MirrorRecursively(root) {
      if (!root) return
      if (!root.left && !root.right) return
      [root.left, root.right] = [root.right, root.left]
      root.left && MirrorRecursively(root.left)
      root.right && MirrorRecursively(root.right)
    }
    return root
};
```

#### 测试用例

- 功能测试
  - 普通的二叉树
  - 二叉树所有节点都没有左子树或者右子树
  - 只有一个节点的二叉树

- 特殊输入测试
  - 二叉树根节点为 null

------

#### 本题考点

- 二叉树、树的遍历

- 思维能力

  画图把抽象问题形象化

------

#### 本题扩展

用循环实现本题

------

### 面试题 28 ：对称的二叉树

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

------

解

- 定义对称前序遍历序列
  - 父、右、左

- 如果二叉树的前序遍历序列和对称前序遍历序列一样，则对称

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    return isSymmetrical(root, root)
};
function isSymmetrical(pRoot1, pRoot2) {
    if (!pRoot1 && !pRoot2) return true
    if (!pRoot1 || !pRoot2) return false
    if (pRoot1.val !== pRoot2.val) return false
    return isSymmetrical(pRoot1.left, pRoot2.right) && isSymmetrical(pRoot1.right, pRoot2.left)
}
```

#### 测试用例

- 功能测试
  - 对称的二叉树
  - 因结构而不对称的二叉树
  - 结构对称但是节点的值不对称的二叉树
- 特殊输入测试
  - 二叉树的根节点为 null
  - 只有一个节点的二叉树
  - 所有节点的值都相等的二叉树

------

#### 本题考点

- 二叉树、树的遍历
- 思维能力、画图形象化

------

### 面试题 29 ：顺时针打印矩阵

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

------

解

- 让循环继续的条件是
  - columns > start * 2
  - rows > start * 2

- 从左上角（start，start）开始

  - 第一步（从左到右）：是必需的

  - 第二步（从上到下）：终止行号大于起始行号

  - 第三步（从右到左）：终止行号大于起始行号、终止列号大于起始列号

  - 第四步（从下到上）：终止行号比起始行号至少大 2 、终止列号大于起始列号

```
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function(matrix) {
    if (!matrix.length || !matrix[0].length)
        return []
    let start = 0
    const result = []
    const rows = matrix.length
    const columns = matrix[0].length
    while (columns > start * 2 && rows > start * 2) {
        PrintMatrixInCircle(matrix, start, result, rows, columns)
        start++
    }
    return result
};
function PrintMatrixInCircle(matrix, start, result, rows, columns) {
    let endX = columns - 1 - start
    let endY = rows - 1 - start
    for (let i = start; i <= endX; i++)
        result.push(matrix[start][i])
    if (start < endY) {
        for (let i = start + 1; i <= endY; i++) 
            result.push(matrix[i][endX])
    }
    if (start < endY && start < endX) {
        for (let i = endX - 1; i >= start; i--)
            result.push(matrix[endY][i])
    }
    if (start < endY - 1 && start < endX) {
        for (let i = endY - 1; i > start; i--)
            result.push(matrix[i][start])
    }
}
```

#### 测试用例

- 数组中有多行多列
- 数组只有一行
- 数组只有一列
- 数组中只有一行一列

#### 本题考点

- 思维能力：画图

------

## 4.3 举例让抽象问题具体化

- 面试题 31 ：“栈的压入、弹出序列”

- 面试题 33 ：“二叉搜索树的后序遍历序列”

### 面试题 30 ：包含 min 函数的栈

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

------

- 用辅助栈存最小值

- 往栈里压入数字

  - 如果压入数字小于辅助栈栈顶数字

    则辅助栈压入该数字

  - 否则辅助栈压入辅助栈栈顶的数字

```
/**
 * initialize your data structure here.
 */
var MinStack = function() {
    this.m_data = []
    this.m_min = []
};

/** 
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
    const {m_data, m_min} = this
    m_data.push(x)
    if (m_min.length && x > m_min[m_min.length - 1])
        m_min.push(m_min[m_min.length - 1])
    else m_min.push(x)
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
    this.m_min.pop()
    return this.m_data.pop()
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
    return this.m_data[this.m_data.length - 1]
};

/**
 * @return {number}
 */
MinStack.prototype.min = function() {
    return this.m_min[this.m_min.length - 1]
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.min()
 */
```

#### 测试用例

- 新压入栈的数比之前的最小值大
- 新压入栈的数字比之前的最小值小
- 弹出栈的数字不是最小元素
- 弹出栈的数字是最小元素

#### 本题考点

- 举具体的例子分析问题
- 栈

------

### 面试题 31 ：栈的压入、弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

------

- 建立一个辅助栈

- 将第一个序列的数字压入辅助栈

- 判断弹出序列

  - 如果下一个弹出的数字是栈顶数字

    直接弹出

  - 否则

    把压栈序列中还没入栈的数字

    压入辅助栈

  - 直到把下一个需要弹出的数字压入栈顶为止

- 如果所有数字都压入栈后

  仍然没有找到下一个弹出的数字

  那么不是弹出序列

```
/**
 * @param {number[]} pushed
 * @param {number[]} popped
 * @return {boolean}
 */
var validateStackSequences = function(pushed, popped) {
    let bPossible = false
        let pNextPush = 0
        let pNextPop = 0
        const nLength = pushed.length
        const stackData = []
        while (pNextPop < nLength) {
            while (!stackData.length ||
            stackData[stackData.length - 1] !== popped[pNextPop]) {
                if (pNextPush === nLength)
                    break
                stackData.push(pushed[pNextPush])
                pNextPush++
            }
            if (stackData[stackData.length - 1] !== popped[pNextPop]) break
            stackData.pop()
            pNextPop++
        }
        if (!stackData.length && pNextPop === nLength) bPossible = true
    return bPossible
};
```

#### 测试用例

- 功能测试
  - 输入的两个数组含有多个数字或者只有一个数字
  - 第二个数组是或者不是第一个数组表示的压入序列对应的栈的弹出序列

- 特殊输入测试

  输入两个空数组

  ------

#### 本题考点

- 分析复杂问题：举具体例子，找规律
- 栈

