# 第 4 章 解决面试题的思路

## 4.2 画图让抽象问题形象化

- 二叉树、二维数组、链表
- 面试题 27 ：“ 二叉树的镜像 ”
- 面试题 29 ：“顺时针打印矩阵”
- 面试题 35 ：“复杂链表的复制”

### 面试题 27 ：二叉树的镜像

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

------

- 前序遍历每个节点

  - 如果遍历的节点有子节点

    就交换它的两个子节点

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var mirrorTree = function(root) {
    if (!root) return null
    if (!root.left && !root.right) return root
    MirrorRecursively(root)
    function MirrorRecursively(root) {
      if (!root) return
      if (!root.left && !root.right) return
      [root.left, root.right] = [root.right, root.left]
      root.left && MirrorRecursively(root.left)
      root.right && MirrorRecursively(root.right)
    }
    return root
};
```

#### 测试用例

- 功能测试
  - 普通的二叉树
  - 二叉树所有节点都没有左子树或者右子树
  - 只有一个节点的二叉树

- 特殊输入测试
  - 二叉树根节点为 null

------

#### 本题考点

- 二叉树、树的遍历

- 思维能力

  画图把抽象问题形象化

------

#### 本题扩展

用循环实现本题

------

### 面试题 28 ：对称的二叉树

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

------

解

- 定义对称前序遍历序列
  - 父、右、左

- 如果二叉树的前序遍历序列和对称前序遍历序列一样，则对称

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    return isSymmetrical(root, root)
};
function isSymmetrical(pRoot1, pRoot2) {
    if (!pRoot1 && !pRoot2) return true
    if (!pRoot1 || !pRoot2) return false
    if (pRoot1.val !== pRoot2.val) return false
    return isSymmetrical(pRoot1.left, pRoot2.right) && isSymmetrical(pRoot1.right, pRoot2.left)
}
```

#### 测试用例

- 功能测试
  - 对称的二叉树
  - 因结构而不对称的二叉树
  - 结构对称但是节点的值不对称的二叉树
- 特殊输入测试
  - 二叉树的根节点为 null
  - 只有一个节点的二叉树
  - 所有节点的值都相等的二叉树

------

#### 本题考点

- 二叉树、树的遍历
- 思维能力、画图形象化

------

### 面试题 29 ：顺时针打印矩阵

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

------

解

- 让循环继续的条件是
  - columns > start * 2
  - rows > start * 2

- 从左上角（start，start）开始

  - 第一步（从左到右）：是必需的

  - 第二步（从上到下）：终止行号大于起始行号

  - 第三步（从右到左）：终止行号大于起始行号、终止列号大于起始列号

  - 第四步（从下到上）：终止行号比起始行号至少大 2 、终止列号大于起始列号

```
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function(matrix) {
    if (!matrix.length || !matrix[0].length)
        return []
    let start = 0
    const result = []
    const rows = matrix.length
    const columns = matrix[0].length
    while (columns > start * 2 && rows > start * 2) {
        PrintMatrixInCircle(matrix, start, result, rows, columns)
        start++
    }
    return result
};
function PrintMatrixInCircle(matrix, start, result, rows, columns) {
    let endX = columns - 1 - start
    let endY = rows - 1 - start
    for (let i = start; i <= endX; i++)
        result.push(matrix[start][i])
    if (start < endY) {
        for (let i = start + 1; i <= endY; i++) 
            result.push(matrix[i][endX])
    }
    if (start < endY && start < endX) {
        for (let i = endX - 1; i >= start; i--)
            result.push(matrix[endY][i])
    }
    if (start < endY - 1 && start < endX) {
        for (let i = endY - 1; i > start; i--)
            result.push(matrix[i][start])
    }
}
```

#### 测试用例

- 数组中有多行多列
- 数组只有一行
- 数组只有一列
- 数组中只有一行一列

#### 本题考点

- 思维能力：画图

------

## 4.3 举例让抽象问题具体化

- 面试题 31 ：“栈的压入、弹出序列”

- 面试题 33 ：“二叉搜索树的后序遍历序列”

### 面试题 30 ：包含 min 函数的栈

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

------

- 用辅助栈存最小值

- 往栈里压入数字

  - 如果压入数字小于辅助栈栈顶数字

    则辅助栈压入该数字

  - 否则辅助栈压入辅助栈栈顶的数字

```
/**
 * initialize your data structure here.
 */
var MinStack = function() {
    this.m_data = []
    this.m_min = []
};

/** 
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
    const {m_data, m_min} = this
    m_data.push(x)
    if (m_min.length && x > m_min[m_min.length - 1])
        m_min.push(m_min[m_min.length - 1])
    else m_min.push(x)
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
    this.m_min.pop()
    return this.m_data.pop()
};

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
    return this.m_data[this.m_data.length - 1]
};

/**
 * @return {number}
 */
MinStack.prototype.min = function() {
    return this.m_min[this.m_min.length - 1]
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.min()
 */
```

#### 测试用例

- 新压入栈的数比之前的最小值大
- 新压入栈的数字比之前的最小值小
- 弹出栈的数字不是最小元素
- 弹出栈的数字是最小元素

#### 本题考点

- 举具体的例子分析问题
- 栈

------

### 面试题 31 ：栈的压入、弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

------

- 建立一个辅助栈

- 将第一个序列的数字压入辅助栈

- 判断弹出序列

  - 如果下一个弹出的数字是栈顶数字

    直接弹出

  - 否则

    把压栈序列中还没入栈的数字

    压入辅助栈

  - 直到把下一个需要弹出的数字压入栈顶为止

- 如果所有数字都压入栈后

  仍然没有找到下一个弹出的数字

  那么不是弹出序列

```
/**
 * @param {number[]} pushed
 * @param {number[]} popped
 * @return {boolean}
 */
var validateStackSequences = function(pushed, popped) {
    let bPossible = false
        let pNextPush = 0
        let pNextPop = 0
        const nLength = pushed.length
        const stackData = []
        while (pNextPop < nLength) {
            while (!stackData.length ||
            stackData[stackData.length - 1] !== popped[pNextPop]) {
                if (pNextPush === nLength)
                    break
                stackData.push(pushed[pNextPush])
                pNextPush++
            }
            if (stackData[stackData.length - 1] !== popped[pNextPop]) break
            stackData.pop()
            pNextPop++
        }
        if (!stackData.length && pNextPop === nLength) bPossible = true
    return bPossible
};
```

#### 测试用例

- 功能测试
  - 输入的两个数组含有多个数字或者只有一个数字
  - 第二个数组是或者不是第一个数组表示的压入序列对应的栈的弹出序列

- 特殊输入测试

  输入两个空数组

  ------

#### 本题考点

- 分析复杂问题：举具体例子，找规律
- 栈

------

### 面试题 32 ：从上到下打印二叉树

#### 题目一：不分行从上到下打印二叉树

------

- 每打印一个节点时

  - 如果该节点有子节点

    则把该节点的子节点放到队列末尾

  - 到队列头部取出最早进入队列的节点

  - 重复前面的操作

    直到所有节点被打印

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if (!root) return null
    const result = []
    const dequeTreeNode = []
    dequeTreeNode.push(root)
    while (dequeTreeNode.length) {
        let pNode = dequeTreeNode[0]
        result.push(dequeTreeNode.shift().val)
        pNode.left && dequeTreeNode.push(pNode.left)
        pNode.right && dequeTreeNode.push(pNode.right)
    }
    return result
};
```

##### 测试用例

- 功能测试
  - 完全二叉树
  - 所有节点只有左子树的二叉树
  - 所有节点只有右子树的二叉树
- 特殊输入测试
  - 二叉树根节点为 null
  - 只有一个节点的二叉树

------

##### 本题考点

- 思维能力 ：通过具体例子找规律
- 二叉树和队列

------

##### 本题扩展

如何广度优先遍历一幅有向图

- 用队列实现

- 树是图的一种特殊退化形式

  从上到下遍历

------

##### 举一反三

- 广度优先都要用到队列
- 首先起始节点放入队列
- 每次从队列头部取出一个节点
- 遍历这个节点
- 把该节点相邻节点放入队列
- 直到队列中的节点全部被遍历为止

------

#### 题目二 ：分行从上到下打印二叉树

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

------

- 两个变量
  - 一个表示当前层还没有打印的节点数
- 一个表示下一层节点数

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if (!root) return []
    const nodes = []
    let temp = []
    const result = []
    nodes.push(root)
    let nextLevel = 0
    let toBePrinted = 1
    while (nodes.length) {
        const pNode = nodes.shift()
        temp.push(pNode.val)
        pNode.left && nodes.push(pNode.left) && nextLevel++
        pNode.right && nodes.push(pNode.right) && nextLevel++
        toBePrinted--
        if (toBePrinted === 0) {
            result.push(temp)
            toBePrinted = nextLevel
            nextLevel = 0
            temp = []
        }
    }
    return result
};
```

##### 测试用例

- 同上

------

##### 本题考点

- 同上

------

#### 题目三 ：之字形打印二叉树

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

------

- 两个栈

  - 如果是奇数层

    则先保存左子节点

    后保存右子节点

    到第一个栈

  - 如果是偶数层

    则先保存右子节点

    后保存左子节点

    到第二个栈

- 逐个弹出栈顶的节点并打印

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if (!root) return []
    const result = []
    const levels = Array(2)
    levels[0] = []
    levels[1] = []
    let temp = []
    let current = 0
    let next = 1
    levels[current].push(root)
    while (levels[0].length || levels[1].length) {
        const pNode = levels[current].pop()
        temp.push(pNode.val)
        if (current === 0) {
            pNode.left && levels[next].push(pNode.left)
            pNode.right && levels[next].push(pNode.right)
        } else {
            pNode.right && levels[next].push(pNode.right)
            pNode.left && levels[next].push(pNode.left)
        }
        if (!levels[current].length) {
            result.push(temp)
            temp = []
            current = 1 - current
            next = 1 - current
        }
    }
    return result
};
```

##### 测试用例

- 同上

##### 本题考点

- 同上

------

### 面试题 33 ：二叉搜索树的后序遍历序列

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。

------

- 后序遍历序列中
  - 最后一个数字是根节点
  - 前面的数字分为两部分
    - 第一部分是左子树节点的值，都比根节点的值小
    - 第二部分是右子树节点的值，都比根节点的值大

```
/**
 * @param {number[]} postorder
 * @return {boolean}
 */
var verifyPostorder = function(postorder) {
    if (!postorder.length) return true
    const nLength = postorder.length
    const root = postorder[nLength - 1]
    let leftIndex = 0
    for (; leftIndex < nLength - 1; leftIndex++) {
        if (postorder[leftIndex] > root)
            break
    }
    let rightIndex = leftIndex
    for (; rightIndex < nLength - 1; rightIndex++) {
        if (postorder[rightIndex] < root)
            return false
    }
    let left = true
    if (leftIndex > 0)
        left = verifyPostorder(postorder.slice(0, leftIndex))
    let right = true
    if (leftIndex < nLength - 1)
        right = verifyPostorder(postorder.slice(leftIndex, nLength - 1))
    return (left && right)
};
```

#### 测试用例

- 功能测试

  - 输入的后序遍历序列对应一棵二叉树

    包括

    - 完全二叉树
    - 所有节点都没有左 / 右子树的二叉树
    - 只有一个节点的二叉树

  - 输入的后序遍历序列没有对应一颗二叉树

- 特殊输入测试
  - 后续遍历序列为空数组

#### 本题考点

- 分析问题
  - 从例子入手
  - 找出后序遍历的规律
  - 用递归实现

- 二叉树的后序遍历的理解

#### 相关题目

- 输入一个整数数组

  判断数组时候是二叉搜索树的前序遍历结果

- 与本题解法类似
  - 不同点：根节点为第一个数字

#### 举一反三

- 如果要求处理二叉树的遍历序列

  - 先找到根节点

  - 根据根节点

    把序列分为左子树和右子树对应的两个序列

  - 递归处理这两个序列

- 面试题 7 “重建二叉树” 思路类似

