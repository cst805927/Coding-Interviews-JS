# 第 2 章 面试需要的基础知识

## 2.3 数据结构

数组、字符串、链表、树、栈、队列

最基本：数组、字符串

出现频率最高：链表、树

栈——递归

队列——广度优先

------

### 2.3.1 数组

O(1) 读写元素

哈希表：

- 下标：key

- 数组中的数字：value

------

#### 面试题3：数组中重复的数字

------

##### 题目一：找出数组中重复的数字。

在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。

数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。

请找出数组中任意一个重复的数字。

例如：长度为 7 的数组 [2, 3, 1, 0, 2, 5, 3] 对应重复数字 2 或 3

------

解：

数组中数字在0~n-1范围内，

如果没有重复，数组排序后，数字 i 出现在下标为 i 的位置

由于有重复，有些位置对应多个数字



重排数组

判断下标为 i 的数字（m）是否等于 i

- 如果相等，扫描下一个数字

- 如果不相等，判断是否等于下标为 m 的数字，

  - 如果相等，则找到一个重复数字，

  - 如果不相等，将数字 m 放到下标为 m 的位置，两个数字交换位置

重复这个比较、交换过程，直到找到第一个重复数字

```
/**
 * @param {number[]} nums
 * @return {number}
 */
var findRepeatNumber = function(nums) {
    if (!nums.length) return false
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] < 0 || nums[i] >= nums.length)
            return false
    }
    for (let i = 0; i < nums.length; i++) {
        while (nums[i] !== i) {
            if (nums[i] === nums[nums[i]])
                return nums[i]
            const temp = nums[i]
            nums[i] = nums[temp]
            nums[temp] = temp
        }
    }
};
```

时间复杂度：O（n）

- 每个数组至多交换两次

空间复杂度：O（1）

- 在原数组上操作

------

##### 题目二：不修改数组找出重复的数字

在一个长度为 n + 1 的数组里的所有数字都在1 ~ n 的范围内，

所以数组中至少有一个数字重复

请找出数组中任意一个重复的数字，

但不能修改输入的数组

例如：长度为 8 的数组 [2, 3, 5, 4, 3, 2, 6, 7] 对应重复数字为 2 或 3

------

解：

假如没有重复数字， 那么 1 ~ n 的范围里只有 n 个数字

由于数组超过 n 个数字， 所以一定包含了重复数字

在某范围里数字的个数很重要



把 1 ~ n 的数字从中间数字 m 分为两部分，前面一半为 1 ~ m， 后面一半为 m + 1 ~ n

- 如果 1 ~ m 的数字数目超过 m ，那么这一区间一定包含重复数字

- 否则，另一半 m + 1 ~ n 的区间一定包含重复数字

继续把包含重复数字的区间一分为二，

直到找到一个重复数字



这个过程和二分查找很像，

只是多了一步统计区间内数字的数目

```
/**
 * @param {number[]} nums
 * @return {number}
 */
var findRepeatNumber = function(nums) {
   if (!nums.length) return -1
   let start = 0
   let end = nums.length - 1
   while (end >= start) {
       let middle = start + Math.floor((end - start) >> 1)
       let count = countRange(nums, start, middle)
       console.log(start, middle, count)

       if (start === end) {
           if (count > 1) return start
           else break
       }
       if (count > (middle - start + 1))
            end = middle
        else start = middle + 1
   } 
   return -1
};
function countRange(nums, start, end) {
    if (!nums.length) return 0
    let count = 0
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] >= start && nums[i] <= end)
            count++
    }
    return count
}
```

这种算法不能保证找出所有重复数字

例如：[2, 3, 5, 4, 3, 2, 6, 7] 中重复的数字 2

因为在 1 ~ 2 的范围内的数字有两个

不能判断是

- 每个数字各出现一次，

- 某个数字出现两次

------

##### 本题考点：

- 一维数组

- 二分查找

- 和面试官沟通，明确需求

------

#### 面试题4：二维数组中的查找

在一个 n * m 的二维数组中，

每一行都按照从左到右递增的顺序排序，

每一列都按照从上到下递增的顺序排序。

请完成一个高效的函数，输入这样的一个二维数组和一个整数，

判断数组中是否含有该整数。

------

解：

选取数组右上角的数字

- 如果该数字等于要查找的数字，则查找过程结束

- 如果该数字大于要查找的数字，则剔除该数字所在列

- 如果该数字小于要查找的数字，则剔除该数字所在行

```
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {boolean}
 */
var findNumberIn2DArray = function(matrix, target) {
    let found = false
    let rows = matrix.length && matrix.length
    let columns = rows && matrix[0].length
    if (rows > 0 && columns > 0) {
        let row = 0
        let column = columns - 1
        while (row < rows && column >= 0) {
            if (matrix[row][column] === target) {
                found = true
                break
            } else if (matrix[row][column] > target)
                column--
            else row++
        }
    }
    return found
};
```

##### 本题考点

一维数组

通过具体例子找规律

------

### 2.3.2 字符串

------

#### 面试题5：替换空格

请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。

------

解：

遍历一次字符串，

统计出空格总数

每替换一个空格，总长度加 2

替换后的字符串长度 = 原长度 + 空格数 * 2



两个指针 p1 和 p2

- p1 指向原字符串末尾

- p2 指向替换后字符串末尾



- 向前移动 p1

- 将 p1 指向的字符复制到 p2 指向的位置

直到遇到第一个空格



遇到第一个空格后

- p1向前移动一格

- p2 插入字符串 ‘%20’

- p2 向前移动 3 格



当 p1 和 p2 指向同一位置时

所有空格替换完毕

```
/**
 * @param {string} s
 * @return {string}
 */
var replaceSpace = function(s) {
    if (!s.length) return ''
    let originalLength = s.length
    let numberOfBlank = 0
    for (let i = 0; i < s.length; i++) {
        if (s[i] === ' ') numberOfBlank++
    }
    let newLength = originalLength + numberOfBlank * 2
    let indexOfOriginal = originalLength - 1
    let indexOfNew = newLength - 1
    s = s.split('')
    while (indexOfOriginal >= 0 && indexOfNew > indexOfOriginal) {
        if (s[indexOfOriginal] === ' ') {
            s[indexOfNew--] = '0'
            s[indexOfNew--] = '2'
            s[indexOfNew--] = '%'
        } else 
            s[indexOfNew--] = s[indexOfOriginal]
        indexOfOriginal--
    }
    return s.join('')
};
```

##### 本题考点

- 字符串

- 逆向思维，从后向前替换空格

------

##### 相关题目

有两个排序数组 A1 和 A2，

请实现一个函数，

把 A2 中的所有数字插入 A1 中

并且所有的数字是排序的

------

解

如果从前向后在 A1 中复制数组，

会出现多次复制一个数字的情况



更好的办法是

从后向前

比较 A1 和 A2 的数字

并把较大的数字放在 A1 合适的位置

------

##### 举一反三

在合并两个数组时

如果从前向后

需要重复移动数字多次

可以考虑

从后向前

这样减少移动次数

提高效率

------

### 2.3.3 链表

链表是动态的数据结构

创建链表时，无需知道链表长度

插入一个节点时，只需为新节点分配内存

内存分配不是创建时一次性完成的

而是每添加一个节点分配一次内存

由于没有闲置的内存

链表的空间效率比数组高

------

#### 面试题6：从尾到头打印链表

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

------

面试小提示

如果打算修改输入的数据

先问面试官是否允许修改

------

解

从尾到头

第一个遍历到的节点最后一个输出

最后一个遍历的节点第一个输出

典型的后进先出

用栈实现



每经过一个节点

把该节点放入栈

遍历完整个链表

从栈顶逐个输出节点的值

```
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {number[]}
 */
var reversePrint = function(head) {
    const nodes = []
    const result = []
    let pNode = head
    while (pNode !== null) {
        nodes.push(pNode.val)
        pNode = pNode.next
    }
    while (nodes.length) {
        result.push(nodes.pop())
    }
    return result
};
```

##### 本题考点

- 单向链表

- 栈、循环、递归

------

### 2.3.4 树

二叉树遍历方式

- 前序遍历：根，左，右

- 中序遍历：左，根，右

- 后序遍历：左，右，根

- 宽度优先遍历

- 深度优先遍历



二叉树特例：

- 二叉搜索树

- 堆

- 红黑树

------

#### 面试题 7：重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。

假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

------

解

前序遍历序列中

第一个数字是根节点

中序遍历序列中

找到根节点

左边为左子树序列

右边为右子树序列



用同样的方法

分别构建左右子树

用递归完成

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
    if (!preorder.length || !inorder)
     return null
    return ConstructCore(0, preorder.length - 1, 0, inorder.length - 1)
    function ConstructCore(startPreorder, endPreorder, startInorder, endInorder){
    const rootValue = preorder[startPreorder]
    const root = new TreeNode()
    root.val = rootValue
    root.left = root.right = null
    if (startPreorder === endPreorder) {
        if (startInorder === endInorder &&
        preorder[startPreorder] === inorder[endInorder]) return root
    }
    const rootInorder = inorder.indexOf(rootValue)
    if (rootInorder === endInorder &&
    inorder[rootInorder] !== rootValue)
        return false
    const leftLength = rootInorder - startInorder
    const leftPreorderEnd = startPreorder + leftLength
    if (leftLength) 
        root.left = ConstructCore(startPreorder + 1, leftPreorderEnd, startInorder, rootInorder)
    if (leftLength < endPreorder - startPreorder)
        root.right = ConstructCore(leftPreorderEnd + 1, endPreorder, rootInorder + 1, endInorder)
    return root
}
};

```

##### 本题考点

- 二叉树的前序遍历和中序遍历

- 将二叉树大问题分解成左右子树的两个小问题，大问题和小问题本质上一致，用递归

------

### 2.3.5 栈和队列

------

#### 面试题 9 ：用两个栈实现队列

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

------

解

一个队列包含两个栈 stack1 和 stack2

- 删除元素的步骤

  - 当 stack2 不为空时，在 stack2 中的栈顶元素，是最先进入队列的元素， 可以弹出

  - 当 stack2 为空时，把 stack1 中的元素逐个弹出，并压入 stack2

- 插入元素的步骤
  - 把插入元素压入 stack1

```
var CQueue = function() {
   this.stack1 = []
   this.stack2 = []
};

/** 
 * @param {number} value
 * @return {void}
 */
CQueue.prototype.appendTail = function(value) {
    this.stack1.push(value)

};

/**
 * @return {number}
 */
CQueue.prototype.deleteHead = function() {
    const stack1 = this.stack1
    const stack2 = this.stack2
    if(!stack2.length){
        while(stack1.length > 0){
            stack2.push(stack1.pop())
        }
    }
    if(!stack2.length) return -1
    return stack2.pop()
};

/**
 * Your CQueue object will be instantiated and called as such:
 * var obj = new CQueue()
 * obj.appendTail(value)
 * var param_2 = obj.deleteHead()
 */
```

##### 本题考点

- 栈和队列的理解

- 模板相关的代码

- 分析复杂问题的能力，通过画图把抽象问题形象化

------

##### 相关题目

用两个队列实现一个栈

------

解

两个队列 queue1 和 queue2

- 插入一个元素
  - 将待插入元素插入 queue1

- 弹出一个元素
  - 如果 queue1 元素数目大于 1 ，弹出 queue1 中的元素，并插入到 queue2
  - 如果 queue1 元素数目等于 1 ，弹出队头元素，并返回该元素

------

## 2.4 算法和数据操作

重点：排序、查找

重点掌握：二分查找、归并排序、快速排序



二维数组搜索路径：回溯法——递归或者栈实现



求某问题的最优解，并且该问题可以分为多个子问题——动态规划

为了避免不必要的重复计算，用自下而上的循环代码来实现

就是把子问题的最优解先算出来

并用数组保存下来

接下来基于子问题的解计算大问题的解



动态规划思路中

分解子问题的时候存在某个特殊选择

如果采用这个特殊选择一定能得到最优解

贪婪算法



位运算

可以看成一类特殊算法

把数字表示成二进制之后

对 0 和 1 的操作

总共有五种位运算：与、或、异或、左移、右移

------

### 2.4.1 递归和循环

需要重复多次计算相同问题

选择用递归或循环



递归是在一个函数内部调用这个函数自身

循环是通过设置计算的初始值及终止条件，在一个范围内重复运算



在树的前序、中序、后序遍历算法的代码中

递归的实现明显比循环简单得多

在面试时，如果面试官没有特别的要求

可以尽量多采用递归的方法编程

#### 面试小提示

通常基于递归实现的代码比基于循环实现的代码

要简洁很多

更容易实现

如果面试官没有特殊要求

应聘者可以优先采用递归



递归的缺点

由于调用自身

而函数调用是有时间和空间消耗的

每一次函数调用

都要在内存栈中分配空间

以保存参数、返回地址、临时变量

而且往栈里压入数据和弹出数据都需要时间

所以递归实现的效率不如循环



递归有可能很多计算都是重复的

从而对性能带来很大的影响

递归本质是一个问题分解成两个或者多个小问题

如果多个小问题有互相重叠的部分

就存在重复的计算



通常应用动态规划解决问题时

我们都是用递归的思路分析问题

但是由于递归分解的子问题中存在大量的重复

因此总是用自下而上的循环

来实现代码

用递归分析问题，并基于循环写代码：面试题14、47、48



递归严重的问题：调用栈溢出

每一次函数调用在内存栈中分配空间

而每个进程的栈的容量是有限的

当递归调用的层级太多

就会超出栈的容量

从而导致调用栈的溢出

------

#### 面试题 10 ：斐波那契数列

##### 题目一：

写一个函数，输入 n ，

求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。

斐波那契数列的定义如下：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

------

解

从下往上计算

根据 f（0）和 f（1）算出 f（2）

再根据 f（1）和 f（2）算出 f（3）

以此类推算出第 n 项

时间复杂度 O（n）

```

```

