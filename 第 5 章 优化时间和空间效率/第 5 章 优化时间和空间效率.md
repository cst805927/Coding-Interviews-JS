# 第 5 章 优化时间和空间效率

## 5.2 时间效率

- 习惯

  - 用指针的习惯

- 递归和循环的效率区别

  - 用递归的思路分析问题，

    写代码用数组来保存中间结果基于循环实现

- 数据结构和算法掌握程度

  - 查找
    - 顺序查找需要 O（n）
    - 排序数组需要 O（logn）
    - 哈希表需要 O（1）

- 敏捷的思维
  - 从不同角度去思考问题

### 面试题 39 ：数组中出现次数超过一半的数字

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

------

#### 解法一 ：基于 Partition 函数的解法

- 数组的出现的次数超过了数组长度的一半

  如果把这个数组排序，

  那么排序之后位于数组中间的数字一定所求的数字

  - 这个数字是中位数

  - 这个数字就是长度为 n 的数组中第 n / 2 大的数字
  - O（n）求数组第 k 大的数字

- 随机快速排序的算法中

  - 先在数组中随机选择一个数字
  - 然后调整数组中的数字顺序
    - 使得比选中的数字小的在左边，大的在右边

- 如果选中的数字的下标刚好是 n / 2

  - 那么这个数字就是数组的中位数

- 如果它的下标大于 n / 2

  - 那么中位数在它的左边

  - 接着在它的左边查找

- 如果它的下标大于 n / 2

  - 中位数位于它的右边

  - 右边部分的数组中查找

- 用递归实现

```
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
    if (!nums.length) return null
    let middle = nums.length >> 1
    let start = 0
    let end = nums.length - 1
    let index = Partition(nums, start, end)
    while (index !== middle) {
        if (index === middle) {
            return nums[index]
        } else if (index > middle) {
            end = index - 1
            index = Partition(nums, start, end)
        } else {
            start = index + 1
            index = Partition(nums, start, end)
        }
    }
    let result = nums[middle]
    if (!CheckMoreThanHalf(nums, result)) return null
    return result
};
function CheckMoreThanHalf(numbers, number) {
    let times = 0
    for (let i = 0; i < numbers.length; i++) {
        if (numbers[i] === number)
            times++
    }
    if ((times << 1) <= numbers.length) return false
    else return true
}
function Partition(nums, start, end) {
    if (!nums.length || start < 0 || end >= nums.length) return -1
    let index = Math.floor(Math.random() * (end - start + 1) + start);
    [nums[index], nums[end]] = [nums[end], nums[index]]
    let small = start - 1
    for (let index = start; index < end; index++) {
        if (nums[index] < nums[end]) {
            small++
            if (small !== index) 
                [nums[index], nums[small]] = [nums[small], nums[index]]
        } 
    }
    small++
    [nums[small], nums[end]] = [nums[end], nums[small]]
    return small
}
```

CheckMoreThanHalf函数考虑到

数组中频率最高的数字的次数

没有超过数组长度的一半

#### 解法二 ：根据数组特点找出 O（n）的算法

- 数组中有一个数字出现次数超过数组长度的一半

  即它出现的次数比其它所有数字出现的次数和还要多

- 保存两个值

  - 一个是数组中的一个数字
  - 另一个是次数

- 当我们遍历到下一个数字的时候

  - 如果下一个数字和之前保存的数字相同

    - 则次数加 1

  - 如果下一个数字和之前保存的数字不同

    - 则次数减 1

  - 如果次数为 0

    - 那么需要保存下一个数字

    - 并把次数设为 1

- 由于要找的数字出现的次数比其它所有数字出现次数之和还要多

  那么要找的数字肯定是最后一次把次数设为 1 时对应的数字

```
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
    if (!nums.length) return null
    let result = nums[0]
    let times = 1
    for (let i = 1; i < nums.length; i++) {
        if (times === 0) {
            result = nums[i]
            times = 1
        } else if (nums[i] === result) times++
        else times--
    }
    if (!CheckMoreThanHalf(nums, result))
        return null
    return result
};
function CheckMoreThanHalf(numbers, number) {
    let times = 0
    for (let i = 0; i < numbers.length; i++) {
        if (numbers[i] === number) times++
    }
    if (times * 2 <= numbers.length) return false
    return true
}
```

#### 解法比较

- 两种算法时间复杂度都是 O（n）
- 第一种修改输入的数组
- 第二种解法不修改输入的数组

#### 测试用例

- 功能测试
  - 输入的数组中存在一个出现次数超过数组长度一半的数字
  - 输入的数组中不存在一个出现次数超过数组长度一半的数字

#### 本题考点

- 时间复杂度
- 思维的全面性
  - 对无效输入进行相应的处理

### 面试题 40 ：最小的 k 个数

输入整数数组 `arr` ，找出其中最小的 `k` 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

------

#### 解法一 ：O（n）修改输入的数组

- 基于数组的第 k 个数字来调整
  - 比第 k 个数字小的所有数字都位于数组的左边
  - 比第 k 个数字大的所有数字都位于数组的右边
- 位于左边的 k 个数字就是最小的 k 个数字

```
/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number[]}
 */
var getLeastNumbers = function(arr, k) {
    if (!arr.length || k > arr.length || k < 0) return []
    let start = 0
    let end = arr.length - 1
    let index = Partition(arr, start, end)
    while (index !== k - 1) {
        if (index > k - 1) {
            end = index - 1
            index = Partition(arr, start, end)
        } else if (index < k - 1) {
            start = index + 1
            index = Partition(arr, start, end)
        }
    }
    return arr.slice(0, k)
};
function Partition(arr, start, end) {
    if (!arr.length || start < 0 || end >= arr.length || start > end) return -1
    let index = Math.floor(Math.random() * (end - start + 1) + start);
    [arr[index], arr[end]] = [arr[end], arr[index]]
    let small = start - 1
    for (index = start; index < end; index++) {
        if (arr[index] < arr[end]) {
            small++
            if (small !== index) 
                [arr[small], arr[index]] = [arr[index], arr[small]]
        }
    }
    small++
    [arr[end], arr[small]] = [arr[small], arr[end]]
    return small
}
```



#### 解法二 ：O（nlogK）的算法，适合海量数据

- 找出已有的 k 个数的最大值

- 创建一个大小为 k 的数据容器，存储最小的 k 个数

- 当容器满了后，做 3 件事

  - 一是在 k 个整数中找到最大值
  - 二是可能在这个容器中删除最大值
  - 三是可能要插入一个新的数字

- 因为每次都要找最大值

  所以用最大堆

  （根节点是最大值）

#### 面试小提示

- 如果有多种解法，每种解法都有优缺点

  要问清楚题目要求，输入特点

  找到最合适的解法

#### 测试用例

- 功能测试
  - 输入的数组中有相同的数字
  - 输入的数组中没有相同的数字
- 边界值测试
  - 输入的 k 等于 1 或者等于数组的长度
- 特殊输入测试
  - k 小于 1
  - k 大于数组的长度
  - 数组为 null

#### 本题考点

- 分析时间复杂度
- 对Partition函数的理解
  - 该函数是快排的基础
  - 也可以用来查找 n 个数中第 k 大的数字

- 对堆、红黑树的理解

  - 当需要某个容器内频繁查找及替换最大值时

    用二叉树

    堆或红黑树

### 面试题 41 ：数据流中的中位数

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

------

- 用一个最大堆实现左边的数据容器

- 用一个最小堆实现右边的数据容器

- 保证数据平均分配到两个堆

  - 因此两个堆中数据的数目之差不能超过 1
  - 在数据总数目是偶数是把新数据插入最小堆
  - 否则插入最大堆

- 最小堆所有数据都要大于最大堆中的数据

  - 当数据总数目是偶数时，

    - 先把这个新的数据插入最大堆

    - 接着把最大堆中的最大值拿出来插入最小堆
      - 由于最终插入最小堆的数字是原最大堆中的最大的数字
      - 这就保证了最小堆中所有数字都大于最大堆的数字

  - 当数据总数目是奇数时同理

#### 测试用例

- 功能测试
  - 从数据流中读出奇数个数字
  - 从数据流中读出偶数个数字
- 边界值测试
  - 从数据流中读出 0 个、1 个、2 个数字

#### 本题考点

- 时间复杂度分析
- 数据结构、最大堆、最小堆

### 面试题 42 ：连续子数组的最大和

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

------

#### 解法一：举例分析数组的规律

- 从头到尾逐个累加数组中的每个数字
- 初始化和为 0
- 第一步加上数字 1
- 第二步加上数字 -2， 和就变成了 -1
- 第三步加上数字 3，
- 如果用 -1 加上 3，得到的和是 2， 比 3 本身还小
- 第一个数字开始的子数组的和会小于从第三个数字开始的子数组的和

- 因此不考虑从第一个开始的子数组，之前累加的也抛弃
- 从第三个数字开始累加

```
/**
 * @param {number[]} nums
 * @return {number}
 */
 let g_InvalidInput = false
var maxSubArray = function(nums) {
    if (!nums.length) {
        g_InvalidInput = true
        return 0
    }
    g_InvalidInput = false
    let nCurSum = 0
    let nGreatestSum = nums[0]
    for (let i = 0; i < nums.length; i++) {
        if (nCurSum <= 0)
            nCurSum = nums[i]
        else nCurSum += nums[i]  
        if (nCurSum > nGreatestSum)
            nGreatestSum = nCurSum  
    }
    return nGreatestSum
};
```

#### 解法二 ：应用动态规划法

- 如果用函数 f(i) 表示以第 i 个数字结尾的子数组的最大和
  - 需要求出max[f(i)]
  - 递归公式
  - f（i） = pData【i】 （i = 0 或者 f（i - 1）< 0）
  -  f（i）= f（i - 1） + pData【i】（i != 0 并且 f（i - 1）> 0）

#### 测试用例

- 功能测试
  - 输入的数组中有正数也有负数
  - 输入的数组中全是正数
  - 输入的数组中全是负数
- 特殊输入测试
  - 表示的数组的指针为 null

#### 本题考点

- 时间复杂度
- 动态规划
- 思维全面性
  - 合理处理无效输入