# 第 6 章 面试中的各项能力

## 6.2 沟通能力和学习能力

### 沟通能力

- 介绍项目经验

  介绍解题思路时

  都需要逻辑清晰明了

  语言详略得当

  表述的时候重点突出、观点明确

### 学习能力

- 两种方法考察学习能力

  - 第一种方法是询问最近在看什么书，做什么项目、从中学到了什么技术

  - 第二种方法是抛出一个新概念，

    观察应聘者能不能在短时间之内理解这个概念

    并解决相关的问题

    - 面试题 11 “旋转”
    - 面试题 27 “二叉树的镜像”
    - 面试题 49 “丑数”
    - 面试题 51 “逆序对”

### 善于学习、沟通的人也善于提问

- 学习能力强的人具有主动积极的态度，

  对未知的领域有强烈的求知欲望

- 因此面试过程种遇到不明白的地方多提问

### 面试小提示

- 面试是双向交流的过程

  - 如果应聘者针对面试题主动提出高质量的问题

    面试官会觉得他又很强的沟通能力和学习能力

## 6.3 知识迁移能力

- 知识迁移能力就是把经典的问题稍作变换

  这是能找到和经典问题的联系

  并从中收到启发

  把解决经典问题的思路迁移过来解决新的问题

  - 面试题 53 “在排序数组中查找数字”

    - 看到“排序数组”就可以想到二分查找算法

    - 通常二分查找算法用来在一个排序数组中查找一个数字

    - 用二分查找算法在排序数组中查找重复数字的第一个和最后一个

      从而得到数字在数组中出现的次数

- 考察迁移能力的另一种方法就是

  先问一个简单的问题，

  在应聘者解答完这个简单问题后

  再追问一个相关，同时难度更大的问题

  - 面试官希望应聘者能总结前面解决简单问题的经验

    把前面的思路、方法迁移过来

  - 面试题 56 “数组中数字出现的次数”

    - 先问一个简单的问题，即数组中只有一个数字只出现一次的情况

    - 再追问如果数组中有两个数字只出现一次

      - 既然有办法找到数组中只出现一次的一个数字

        那么当数组中有两个数字只出现一次的时候

        就可以把数组一分为二

        每个子数组中包含一个只出现一次的数字

        我们就能再两个子数组中分别找到那两个只出现一次的数字

- 知识迁移能力就是“举一反三”的能力

  - 不可能把所有的面试题都准备一遍

  - 更重要的是每做一道题，

    都要总结这道题的解法有什么特点，

    有哪些思路是可以应用到同类型的题目中去的

  - 面试题 “反转单词顺序”

    - 先翻转整个句子的所有字符

    - 再分别翻转每个单词中的字符

    - 这样多次翻转字符的思路

      也可以运用到面试题 58  “左旋转字符串”

  - 在解决面试题 38 “字符串的排列” 之后
    - 发现“八皇后问题”其实是数组的排列问题

- 本书的很多题后，列举了与这道题相关的题目

  可以分析这些题目的相关性

  来提高举一反三的能力

### 面试题 53 ：在排序数组中查找数字

#### 题目一 ：统计一个数字在排序数组中出现的次数。

------

- 排序数组，想到二分查找

- 找到第一个 k 和最后一个 k 的位置

- 如何用二分查找算法在数组中找到第一个 k

  - 二分查找总是拿中间的数字和 k 作比较

  - 如果中间的数字比 k 大，那么 k只可能出现在数组的前半段

    - 下一轮在数组的前半段查找就行

  - 如果中间的数字比 k 小，那么k只可能出现在数组的后半段

    - 下一轮在数组的后半段查找就行

  - 如果中间的数字与 k 相等

    - 先判断这个数字是不是第一个 k

      - 如果中间数字的前面一个数字不是 k，

        那么此时中间的数字刚好是第一个 k 

      - 如果中间数字的前面一个数字也是 k

        那么第一个 k 肯定在前半段，

        下一轮仍然要在前半段查找

- 同样的思路在排序数组找到最后一个 k

  - 如果中间数字比 k 大，那么 k 只能出现在数组的前半段
  - 如果中间数字比 k 小，那么 k 只能出现在数组的后半段
  - 如果中间数字等于 k，我们需要判断这个 k 是不是最后一个 k
    - 也就是中间数字的下一个数字是不是也等于 k
    - 如果下一个数字不是 k，则中间数字就是最后一个 k
    - 否则下一轮我们还是要在数组的后半段中去查找

- 在分别找到第一个 k 和最后一个 k 的下标之后，

  就能计算出 k 在数组中出现的次数

```
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let number = 0
    if (nums.length) {
        let first = GetFirstK(nums, target, 0, nums.length - 1)
        let last = GetLastK(nums, target, first, nums.length - 1)
        if (first > -1 && last > -1)
            number = last - first + 1
    }
    return number
};
function GetFirstK(data, k, start, end) {
    if (start > end) return -1
    let middleIndex = start + Math.floor((end - start) >> 1)
    let middleData = data[middleIndex]
    if (middleData === k) {
        if (middleIndex > 0 && data[middleIndex - 1] !== k || middleIndex === 0) return middleIndex
        else end = middleIndex - 1
    } else if (middleData > k)
        end = middleIndex - 1
    else start = middleIndex + 1
    return GetFirstK(data, k, start, end)
}
function GetLastK(data, k, start, end) {
    if (start > end) return -1
    let middleIndex = start + Math.floor((end - start) >> 1)
    let middleData = data[middleIndex]
    if (middleData === k) {
        if ((middleIndex < data.length - 1 && data[middleIndex + 1] !== k) || middleIndex === data.length - 1) return middleIndex
        else start = middleIndex + 1
    } else if (middleData < k)
        start = middleIndex + 1
    else end = middleIndex - 1
    return GetLastK(data, k, start, end)
}
```

##### 测试用例

- 功能测试
  - 数组中包含要查找的数字
  - 数组中没有要查找的数字
  - 要查找的数字在数组中出现一次
- 边界值测试
  - 查找数组中的最大值、最小值
  - 数组中只有一个数字
- 特殊输入测试
  - 数组为空

#### 题目二 ：0 ~ n - 1 中缺失的数字

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

------

- 基于二分查找

- 如果中间元素的值和下标相等

  那么下一轮查找只需要查找右半边

- 如果中间元素的值和下标不相等

  并且它前面一个元素和它的下标相等

  - 这意味着这个中间的数字正好是第一个值和下标不相等的元素

    它的下标就是数组中缺失的数字

- 如果中间元素的值和下标不相等

  并且它前面一个元素和它的下标不相等

  - 这意味着下一轮查找我们只需要在左半边查找即可

```
/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
    if (!nums.length) return -1
    let left = 0
    let right = nums.length - 1
    while (left <= right) {
        let middle = left + Math.floor((right - left) >> 1)
        if (nums[middle] !== middle) {
            if (middle === 0 || nums[middle - 1] === middle - 1) return middle
            right = middle - 1
        } else left = middle + 1
    }
    if (left === nums.length) return nums.length
    return -1 
};
```

##### 测试用例

- 功能测试
  - 缺失的数字位于数组的开始、中间或者末尾
- 边界值测试
  - 数组中只有一个数字 0
- 特殊输入测试
  - 空数组

#### 题目三 ：数组中数值和下标相等的元素

假设一个单调递增的数组里的每个元素都是整数并且是唯一的

请实现一个函数，找出数组中任意一个数值等于其下标的元素

------

- 用二分查找

- 假设某一步抵达数组的第 i 个数字

  - 如果该数字刚好是 i

    那么就找到一个数字和其下标相等

  - 当数字的值和下标不相等时

    假设数字的值为m

    - 当 m 大于 i 的情况

      即数字的值大于它的下标

      - 由于数组中的所有数字都唯一

        并且单调递增

      - 那么对任意大于 0 的 k

        位于下标 i + k 的数字的值大于或等于 m + k

      - 因此位于下标 i + k 的数字的值一定大于它的下标

        这意味着如果第 i 个数字的值大于 i

        那么它右边的数字都大于对应的下标

        我们都可以忽略

      - 下一轮查找只需要从它的左边的数字中查找即可

    - 数字的值m小于它的下标 i 的情况同上

      它左边所有数字的值都小于对应的下标

- 由于每一步查找时都可以把查找的范围缩小一半

  这是典型的二分查找

```
/**
 * @param {number[]} nums
 * @return {number}
 */
var GetNumberSameAsIndex = function(nums) {
    if (!nums.length) return -1
    let left = 0
    let right = nums.length - 1
    while (left <= right) {
        let middle = left + Math.floor((right - left) >> 1)
        if (nums[middle] === middle) return middle
        if (nums[middle] < middle) left = middle + 1
        else right = middle - 1
    }
    return -1
};
```

##### 测试用例

- 功能测试
  - 数组中包含或者不包含数值和下标相同的元素
- 边界值测试
  - 数组中只有一个数字
  - 数值和下标相等的元素位于数组的开头或者结尾
- 特殊输入测试
  - 空数组

##### 本题考点

- 知识迁移能力

  - 二分查找可以在排序数组总查找一个数字

  - 应聘者如果能运用知识迁移能力

    把问题转换成用二分查找算法在排序数组中查找某些特定的数字

- 对二分查找的理解程度

### 面试题 54 ：二叉搜索树的第 k 大节点

给定一棵二叉搜索树，请找出其中第 `k` 大的节点的值。

- 如果按照中序遍历的顺序遍历一棵二叉搜索树

  则遍历序列的数值是递增排序的

  - 因此，只需要用中序遍历算法遍历一棵二叉搜索树

    很容易找到它的第 k 大节点

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
var kthLargest = function(root, k) {
    if(!root) return null
    const kValue = {val : k}
    const target = KthNodeCode(root, kValue)
    return target.val
};
function KthNodeCode(pRoot, k) {
    let target = null
    if (pRoot.right)
        target = KthNodeCode(pRoot.right, k)
    if (!target) {
        if (k.val === 1) target = pRoot
        k.val--
    }
    if (!target && pRoot.left)
        target = KthNodeCode(pRoot.left, k)
    return target
}
```

#### 测试用例

- 功能测试
  - 各种形态不同的二叉树

- 边界值测试
  - 输入 k 为 0、1、二叉搜索树的节点数、二叉搜索树的节点数加 1
- 特殊输入测试
  - 二叉搜索树的根节点为null

#### 本题考点

- 知识迁移能力

  - 中序遍历

- 二叉搜索树和中序遍历的特点的理解

  - 如果知道二叉搜索树的中序遍历是递增的，

    就很容易就能找出第 k 大的节点

### 面试题 55 ：二叉树的深度

#### 题目一：二叉树的深度

输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。

------

- 如果一棵树只有一个节点，那么它的深度为 1

- 如果根节点只有左子树而没有右子树

  那么树的深度是其左子树的深度加 1

- 如果根节点只有右子树而没有左子树

  那么树的深度是其右子树的深度加 1

- 如果既有左子树又有右子树

  那么树的深度是其左、右子树深度的较大值再加1

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if (!root) return 0
    const nLeft = maxDepth(root.left)
    const nRight = maxDepth(root.right)
    return (nLeft > nRight) ? (nLeft + 1) : (nRight + 1)
};
```

##### 测试用例

- 功能测试
  - 输入普通的二叉树
  - 二叉树中所有节点都没有左/右子树
- 特殊输入测试
  - 二叉树只有一个节点
  - 二叉树的头节点为null

#### 题目二 ：平衡二叉树

输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

------

- 每一个节点只遍历一次的解法

- 用后续遍历的方式遍历二叉树的每个节点

- 那么在遍历到一个节点之前

  我们就已经遍历了它的左右子树

- 只要遍历每个节点的时候记录它的深度

  （某一节点的深度等于它到叶节点的路径的长度）

  就可以一边遍历一边判断每个节点是不是平衡的

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
    const depth = {val : 0}
    return IsBalanced(root, depth)
};
function IsBalanced(root, depth) {
    if (!root) {
        depth.val = 0
        return true
    }
    const left = {val : 0}
    const right = {val : 0}
    if (IsBalanced(root.left, left) && IsBalanced(root.right, right)) {
        const diff = Math.abs(left.val - right.val)
        if (diff <= 1) {
            depth.val = (left.val > right.val) ? (left.val + 1) : (right.val + 1)
            return true
        }
    }
    return false
}
```

##### 测试用例

- 功能测试
  - 平衡二叉树
  - 不是平衡的二叉树
  - 二叉树的所有节点都没有左/ 右子树
- 特殊输入测试
  - 二叉树中只有一个节点
  - 二叉树的头节点为null

#### 本题考点

- 二叉树的理解，树的遍历的应用

- 新概念的学习能力

- 知识迁移能力

  - 从二叉树深度的分析过程得到启发

    找到判断平衡二叉树的突破口

### 面试题 56 ：数组中数字出现的次数

#### 题目一 ：数组中只出现一次的两个数字

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

------

- 先考虑数组中只有一个数字只出现了一次

  其它数字都出现了两次，怎么找出这个数字

- 异或运算性质：任何一个数字异或它自己都等于 0

- 如果从头到尾一次异或数组中的每个数字，

  那么最终的结果刚好是那个只出现一次的数字

  因为哪些成对出现两次的数字全部在异或中抵消了

- 原数组分成两个子数组

  使得每个子数组包含一个只出现一次的数字

  而其它数字都成对出现两次

- 从头到尾依次异或数组中的每个数字

  最终得到的结果是

  两个只出现一次的数字的异或结果

  - 由于这两个数字肯定不一样

    那么异或的结果肯定不为 0

    也就是这个结果数字的二进制中至少有一个 1

    - 在结果找到第一个为 1 的位置，记为第 n 位

    - 现在我们以第 n 位是不是 1 为标准

      把原数组分为两个子数组

      - 第一个子数组中每个数字的第 n 位都是 1

      - 第二个子数组中每个数字的第 n 位都是 0

      - 出现了两次的数字肯定在同一个子数组，

        因为两个两个相同的数字的任意一位都是相同的

```
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var singleNumbers = function(nums) {
    if (!nums.length) return null
    let resultExclusiveOR = 0
    for (let i = 0; i < nums.length; i++)
        resultExclusiveOR ^= nums[i]
    let indexOf1 = FindFirstBitIs1(resultExclusiveOR)
    let num1 = num2 = 0
    for (let i = 0; i < nums.length; i++) {
        if (IsBit1(nums[i], indexOf1))
            num1 ^= nums[i]
        else num2 ^= nums[i]
    }
    return [num1, num2]
};
function FindFirstBitIs1(num) {
    let indexBit = 0
    while (((num & 1) === 0)) {
        num = num >> 1
        indexBit++
    }
    return indexBit
}
function IsBit1(num, indexBit) {
    num = num >> indexBit
    return (num & 1)
}
```

- FindFirstBitIs1 用来在整数 num 的二进制中找到最右边是 1的位
- IsBit1的作用是判断在 num 的二进制中从右边数起的 idexBit 位是不是 1

##### 测试用例

- 功能测试
  - 数组中有多对重复的数字
  - 数组中没有重复的数字

#### 题目二 ：数组中唯一只出现一次的数字

在一个数组 `nums` 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

------

- 如果一个数字出现三次，

  那么它的二进制的每一位（0或者1）也出现三次

  - 如果把所有出现三次的数字的二进制的每一位都分别加起来

    那么每一位的和都能被 3 整除

- 把数组中所有数字的二进制的每一位都加起来

  - 如果某一位的和能被 3 整除

    只出现一次的数字二进制中对应的那一位是 0，

    否则就是 1

```
/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
    if (!nums.length) return null
    let bitSum = Array(32).fill(0)
    for (let i = 0; i < nums.length; i++) {
        let bitMask = 1
        for (let j = 31; j >= 0; j--) {
            let bit = nums[i] & bitMask
            if (bit !== 0)
                bitSum[j] += 1
            bitMask = bitMask << 1
        }
    }
    let result = 0
    for (let i = 0; i < 32; i++) {
        result = result << 1
        result += bitSum[i] % 3
    }
    return result
};
```

- 复杂度

  - 时间复杂度是O（n）
  - 需要长度为32的辅助数组存储二进制的每一位的和
  - 由于数组长度固定，空间复杂度为O（1）

- 该解法的两个特点

  - 很容易从排序数组中找到只出现一次的数字，

    但排序需要O（nlogn）

  - 用哈希表记录数组中每个数字出现的次数

    但这个哈希表需要O（n）的空间

##### 测试用例

- 唯一只出现一次的数字分别是 0、正数、负数
- 重复出现三次的数字分别是 0、正数、负数

##### 本题考点

- 知识迁移能力

  - 其它数字只出现两次而只有一个数字出现一次

    把解决这个简单问题的思路迁移到复杂问题上

    继续从位运算上想办法

- 对二进制和位运算的理解

### 面试题 57 ：和为 s 的数字

#### 题目一 ：和为 s 的两个数字

输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。

------

- 先在数组中选择两个数字

- 如果它们的和等于输入的 s

  那么就找到了要找的两个数字

- 如果两个数字的和小于s

  希望两个数再大一点

  - 由于数组已经排好序了

    选择较小的数字后面的数字

    因为排在后面的数字要大一些

    那么两个数字的和也会大一些

- 同样，当两个数字的和大于 s

  - 选择较大的数字前面的数字

    因为排在数组前面的数字要小一些

```
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    if (!nums.length) return []
    let ahead = nums.length - 1
    let behind = 0
    while (ahead > behind) {
        let curSum = nums[behind] + nums[ahead]
        if (curSum === target) {
            return [nums[behind], nums[ahead]]
        } else if (curSum > target) ahead--
        else behind++
    }
    return []
}; 
```

##### 测试用例

- 功能测试
  - 数组中存在和为 s 的两个数
  - 数组中不存在和为 s 的两个数

- 特殊输入测试
  - 空数组

#### 题目二 ：和为 s 的连续正数序列

输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

------

- 用两个数 small 和 big 分别表示序列的最小值和最大值

- 首先把 small 初始化为 1，big 初始化为2

- 如果从 small 到 big 的序列和大于 s

  则可以从序列中去掉较小的值，

  也就是增大 small 的值

- 如果从 small 到 big 的序列和小于 s

  则可以增大 big

  让这个序列包含更多的数字

- 因为这个序列至少要有两个数字

  所以一直增加 small 到（1+s）/ 2 为止

```
/**
 * @param {number} target
 * @return {number[][]}
 */
var findContinuousSequence = function(target) {
    if (target < 3) return []
    let small = 1
    let big = 2
    let middle = Math.floor((1 + target) >> 1)
    let curSum = small + big
    const result = []
    while (small < middle) {
        if (curSum === target)
            PrintContinuousSequence(small, big, result)
        while (curSum > target && small < middle) {
            curSum -= small
            small++
            if (curSum === target)
                PrintContinuousSequence(small, big, result)
        }
        big++
        curSum += big
    }
    return result
};
function PrintContinuousSequence(small, big, result) {
    const temp = []
    for (let i = small; i <= big; i++)
        temp.push(i)
    result.push(temp)
}
```

- 通常可以用循环求一个连续序列的和

- 但考虑到每次操作之后的序列

  和操作之前的序列相比

  大部分数字都是一样的

  只是增加或减少了一个数字

- 因此可以在前一个序列和的基础上

  求操作之后的序列和

- 这样就减少了很多不必要的运算，提高代码效率

##### 测试用例

- 功能测试
  - 存在和为 s 的连续序列，如 9、100等
  - 不存在和为 s 的连续序列，如 4、0 等
- 边界值测试
  - 连续序列的最小和 3

##### 本题考点

- 复杂问题的思维能力

  - 通过具体例子找规律

- 知识迁移能力

  - 面对第二个问题

    把解决第一个问题的思路应用到新题目上

### 面试题 58 ：翻转字符串

#### 题目一 ：翻转单词的顺序

输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。

------

- 第一步翻转句子中所有的字符
  - 此时不但翻转了句子中单词的顺序
  - 单词内的字符顺序也翻转了
- 第二步再翻转每个单词中字符的顺序
- 就得到了题目要求的输出

```
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
    if (!s) return ''
    const result = s.trim().split(' ').filter(item => item !== '').reverse().join(' ')
    return result
}
```

##### 测试用例

- 功能测试
  - 句子中有多个单词
  - 句子中只有一个单词
- 特殊输入测试
  - 字符串为空
  - 字符串只有空格

#### 题目二 ：左旋转字符串

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

------

- 在第一个问题中

- 如果输入的字符串只有两个的单词，比如 “hello word”

  那么翻转句子中的单词顺序就得到了 “world hello”

- 比较这两个字符串

  可以把 “world hello” 看成是

  原始字符串“hello world”的

  前面若干个字符转移到后面

- 因此同样可以翻转字符串的办法解决第二个问题

- 以 “abcdefg”为例

  - 把它分为两个部分

  - 由于想把它的前两个字符移到后面

    就把前两个字符分到第一部分

    把后面的所有字符分到第二部分

  - 先分别翻转这两个部分

    于是得到“bagfedc“

  - 接下来翻转整个字符串

    得到的”cdefgab“

    刚好是把原始字符串左旋转两位的结果

```
/**
 * @param {string} s
 * @param {number} n
 * @return {string}
 */
var reverseLeftWords = function(s, n) {
    if (s.length) {
        s = s.split('')
        const nLength = s.length
        if (nLength && n > 0 && n < nLength) {
            let pFirstStart = 0
            let pFirstEnd = n - 1
            let pSecondStart = n
            let pSecondEnd = nLength - 1
            Reverse(s, pFirstStart, pFirstEnd)
            Reverse(s, pSecondStart, pSecondEnd)
            Reverse(s, pFirstStart, pSecondEnd)
        }
    }
    return s.join('')
};
function Reverse(s, start, end) {
    while (start < end) {
        [s[start], s[end]] = [s[end],s[start]]
        start++
        end--
    }
}
```

- 两个问题

  - 一是s为空串

  - 二是内存访问越界

    试图访问不属于字符串的内存

    例如 n < 0，n > s.length

##### 测试用例

- 功能测试
  - 把长度为 n 的字符串左旋转 0 个字符、1 个字符、2 个字符、n - 1 个字符、n 个字符、n + 1 个字符
- 特殊输入测试
  - 字符串为空

##### 本题考点

- 知识迁移能力

  - 遇到第二个问题时

    能够把多次翻转字符串的思路迁移过来

    就能轻易解决字符串左旋转的问题

- 字符串

### 面试题 59 ：队列的最大值

#### 题目一 ：滑动窗口的最大值

给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。

------

